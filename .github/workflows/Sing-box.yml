      - name: Download sing-box and check proxies via HTTP 204 (clients3.google.com)
        shell: bash
        run: |
          set -euo pipefail
          SB_VER="1.12.8"   # при необходимости обновите (проверяйте релизы sing-box)
          TMPDIR=$(mktemp -d)
          cd "$TMPDIR"

          echo "Download sing-box v${SB_VER}"
          SB_TGZ="sing-box-${SB_VER}-linux-amd64.tar.gz"
          SB_URL="https://github.com/SagerNet/sing-box/releases/download/v${SB_VER}/${SB_TGZ}"
          curl -fsSL --retry 3 "$SB_URL" -o "$SB_TGZ"
          tar -xzf "$SB_TGZ" --wildcards --strip-components=1 '*/sing-box' || true
          chmod +x sing-box
          ./sing-box -h >/dev/null || true

          SRC="../../dist/combined.txt"
          OUT="../../dist/combined_ok.txt"
          : > "$OUT"

          SOCKS_PORT=10808
          TIMEOUT_CURL=10

          # helper: run check for a given JSON config (client.json)
          check_with_singbox() {
            cfg="$1"
            # run sing-box
            ./sing-box run -c "$cfg" >/dev/null 2>&1 &
            PID=$!
            # give time to start
            sleep 1
            # try a couple of generate_204 endpoints (if any returns 204 -> OK)
            HTTP_CODE=$(curl --socks5-hostname 127.0.0.1:${SOCKS_PORT} -I --max-time $TIMEOUT_CURL -s -o /dev/null -w "%{http_code}" http://clients3.google.com/generate_204 || echo "000")
            if [ "$HTTP_CODE" != "204" ]; then
              HTTP_CODE2=$(curl --socks5-hostname 127.0.0.1:${SOCKS_PORT} -I --max-time $TIMEOUT_CURL -s -o /dev/null -w "%{http_code}" http://www.gstatic.com/generate_204 || echo "000")
            else
              HTTP_CODE2="$HTTP_CODE"
            fi

            # kill sing-box
            kill $PID >/dev/null 2>&1 || true
            wait $PID 2>/dev/null || true

            if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE2" = "204" ]; then
              return 0
            else
              return 1
            fi
          }

          # parse helpers
          parse_vmess() {
            line="$1"
            b64=${line#vmess://}
            json=$(echo "$b64" | base64 --decode 2>/dev/null || true)
            if [ -z "$json" ]; then
              return 1
            fi
            host=$(echo "$json" | python3 -c "import sys, json; o=json.load(sys.stdin); print(o.get('add',''))" 2>/dev/null || true)
            port=$(echo "$json" | python3 -c "import sys, json; o=json.load(sys.stdin); print(o.get('port',''))" 2>/dev/null || true)
            uuid=$(echo "$json" | python3 -c "import sys, json; o=json.load(sys.stdin); print(o.get('id','') or o.get('ps',''))" 2>/dev/null || true)
            # if uuid empty, try "id" or "id" inside 'id' etc
            if [ -z "$uuid" ]; then
              uuid=$(echo "$json" | jq -r '.id // ""' 2>/dev/null || true)
            fi
            echo "$host" "$port" "$uuid"
            return 0
          }

          parse_vless() {
            line="$1"
            # vless://UUID@host:port?...
            proto_removed=${line#vless://}
            before_q=${proto_removed%%\?*}
            uuid=$(echo "$before_q" | cut -d'@' -f1)
            hostport=$(echo "$before_q" | cut -d'@' -f2-)
            host=$(echo "$hostport" | sed -E 's/^\[?([^]]+)\]?:([0-9]+).*$/\1/' 2>/dev/null || true)
            port=$(echo "$hostport" | sed -E 's/^\[?([^]]+)\]?:([0-9]+).*$/\2/' 2>/dev/null || true)
            echo "$host" "$port" "$uuid"
            return 0
          }

          parse_trojan() {
            line="$1"
            # trojan://password@host:port?...
            proto_removed=${line#trojan://}
            before_q=${proto_removed%%\?*}
            password=$(echo "$before_q" | cut -d'@' -f1)
            hostport=$(echo "$before_q" | cut -d'@' -f2-)
            host=$(echo "$hostport" | sed -E 's/^\[?([^]]+)\]?:([0-9]+).*$/\1/' 2>/dev/null || true)
            port=$(echo "$hostport" | sed -E 's/^\[?([^]]+)\]?:([0-9]+).*$/\2/' 2>/dev/null || true)
            echo "$host" "$port" "$password"
            return 0
          }

          parse_ss() {
            line="$1"
            # ss://base64@host:port  OR ss://method:pass@host:port OR ss://base64
            uri=${line#ss://}
            # if contains '@' after scheme and before ':port', handle both
            if echo "$uri" | grep -q "@"; then
              left=${uri%@*}
              right=${uri#*@}
              # right is host:port...
              host=$(echo "$right" | sed -E 's/^\[?([^]]+)\]?:([0-9]+).*$/\1/' 2>/dev/null || true)
              port=$(echo "$right" | sed -E 's/^\[?([^]]+)\]?:([0-9]+).*$/\2/' 2>/dev/null || true)
              # left may be base64 (method:pass) or plain method:pass
              if echo "$left" | grep -qE '^[A-Za-z0-9+/=]+$' ; then
                creds=$(echo "$left" | base64 --decode 2>/dev/null || true)
              else
                creds="$left"
              fi
              method=$(echo "$creds" | cut -d: -f1)
              password=$(echo "$creds" | cut -d: -f2-)
              echo "$host" "$port" "$method" "$password"
              return 0
            else
              # ss://<base64> maybe contains method:pass@host:port encoded; try decode full uri
              dec=$(echo "$uri" | base64 --decode 2>/dev/null || true)
              if [ -n "$dec" ]; then
                # dec format: method:password@host:port
                method=$(echo "$dec" | cut -d: -f1)
                rest=$(echo "$dec" | cut -d: -f2-)
                password=$(echo "$rest" | cut -d@ -f1)
                hostport=$(echo "$rest" | cut -d@ -f2-)
                host=$(echo "$hostport" | sed -E 's/^\[?([^]]+)\]?:([0-9]+).*$/\1/' 2>/dev/null || true)
                port=$(echo "$hostport" | sed -E 's/^\[?([^]]+)\]?:([0-9]+).*$/\2/' 2>/dev/null || true)
                echo "$host" "$port" "$method" "$password"
                return 0
              fi
            fi
            return 1
          }

          # iterate lines
          while IFS= read -r line || [ -n "$line" ]; do
            [ -z "${line//[[:space:]]/}" ] && continue
            echo "CHECK: $line"
            ok=1
            # create temp cfg file
            CFG=$(mktemp -p . --suffix .json)
            handled=0

            if [[ "$line" =~ ^vmess:// ]]; then
              read host port uuid <<< "$(parse_vmess "$line" || echo '')"
              if [ -n "$host" ] && [ -n "$port" ] && [ -n "$uuid" ]; then
                cat > "$CFG" <<JSON
{
  "log": { "level": "error" },
  "inbounds": [
    { "type": "socks", "tag": "socks-in", "server": "127.0.0.1", "port": ${SOCKS_PORT} }
  ],
  "outbounds": [
    { "type": "direct", "tag": "direct" },
    {
      "type": "vmess",
      "tag": "vmess-out",
      "server": "${host}",
      "server_port": ${port},
      "uuid": "${uuid}",
      "security": "auto"
    }
  ]
}
JSON
                handled=1
              fi

            elif [[ "$line" =~ ^vless:// ]]; then
              read host port uuid <<< "$(parse_vless "$line" || echo '')"
              if [ -n "$host" ] && [ -n "$port" ] && [ -n "$uuid" ]; then
                cat > "$CFG" <<JSON
{
  "log": { "level": "error" },
  "inbounds": [
    { "type": "socks", "tag": "socks-in", "server": "127.0.0.1", "port": ${SOCKS_PORT} }
  ],
  "outbounds": [
    { "type": "direct", "tag": "direct" },
    {
      "type": "vless",
      "tag": "vless-out",
      "server": "${host}",
      "server_port": ${port},
      "uuid": "${uuid}"
    }
  ]
}
JSON
                handled=1
              fi

            elif [[ "$line" =~ ^trojan:// ]]; then
              read host port password <<< "$(parse_trojan "$line" || echo '')"
              if [ -n "$host" ] && [ -n "$port" ] && [ -n "$password" ]; then
                cat > "$CFG" <<JSON
{
  "log": { "level": "error" },
  "inbounds": [
    { "type": "socks", "tag": "socks-in", "server": "127.0.0.1", "port": ${SOCKS_PORT} }
  ],
  "outbounds": [
    { "type": "direct", "tag": "direct" },
    {
      "type": "trojan",
      "tag": "trojan-out",
      "server": "${host}",
      "server_port": ${port},
      "password": "${password}"
    }
  ]
}
JSON
                handled=1
              fi

            elif [[ "$line" =~ ^ss:// ]]; then
              if parse_ss "$line" >/dev/null 2>&1; then
                read host port method password <<< "$(parse_ss "$line" || echo '')"
                if [ -n "$host" ] && [ -n "$port" ] && [ -n "$method" ] && [ -n "$password" ]; then
                  cat > "$CFG" <<JSON
{
  "log": { "level": "error" },
  "inbounds": [
    { "type": "socks", "tag": "socks-in", "server": "127.0.0.1", "port": ${SOCKS_PORT} }
  ],
  "outbounds": [
    { "type": "direct", "tag": "direct" },
    {
      "type": "shadowsocks",
      "tag": "ss-out",
      "server": "${host}",
      "server_port": ${port},
      "method": "${method}",
      "password": "${password}"
    }
  ]
}
JSON
                  handled=1
                fi
              fi
            fi

            if [ "$handled" -eq 0 ]; then
              echo "SKIP (unsupported/complex transport): $line"
              rm -f "$CFG" || true
              continue
            fi

            # run check
            if check_with_singbox "$CFG"; then
              echo "OK -> keep"
              echo "$line" >> "$OUT"
            else
              echo "FAIL -> skip"
            fi

            rm -f "$CFG" || true
          done < "$SRC"

          # replace combined with ok list
          if [ -s "$OUT" ]; then
            mv "$OUT" ../../dist/combined.txt
          else
            : > ../../dist/combined.txt
          fi

          cd -
          rm -rf "$TMPDIR"
